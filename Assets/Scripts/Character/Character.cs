using System.Collections.Generic;
using System.Linq;
using NaughtyAttributes;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// A character is an enemy or a player, and contains references to variables
/// used by either. This consolidates references and makes further development
/// much more easier and less bug prone.
///
/// <br/>
///
/// Authors: Ryan Chang (2023)
/// </summary>
[RequireComponent(typeof(Rigidbody2D), typeof(Collider2D), typeof(DefaultFlipModule))]
public class Character : MonoBehaviour
{
    #region Variables
    #region User Settings
    /// <summary>
    /// The current hp of the character. Please use <see cref="HP"/> instead, as
    /// that fires the <see cref="EventManager.onCharacterDeath"/> event.
    /// </summary>
    private int hp;

    /// <summary>
    /// The maximum health of the character.
    /// </summary>
    public int maxHP;

    [Tooltip("The amount of knockback received is multiplied by this number.")]
    public float knockbackMultiplier = 1;
    #endregion

    #region Autogenerated
    [ReadOnly]
    public Rigidbody2D r2d;

    [ReadOnly]
    public Collider2D c2d;

    [ReadOnly]
    public DefaultFlipModule flipModule;

    [ReadOnly]
    public AudioSource defaultAudioSource;

    private Duration damageInvulnerability;
    #endregion
    #endregion

    #region Properties
    /// <summary>
    /// Determines whether or not the character is a player based on the
    /// existence of a <see cref="PlayerMoveModule"/>.
    /// </summary>
    public bool IsPlayer { get; private set; }

    /// <summary>
    /// The current HP of the character. Setting this value also calls <see
    /// cref="EventManager.onCharacterDeath"/> and <see
    /// cref="onCharacterDeathEvent"/> if the character's health drops below 0.
    /// Setting this value also calls 
    /// </summary>
    public int HP
    {
        get => hp;
        private set
        {
            if (hp > value)
            {
                // Character has taken damage.
                onCharacterHurtEvent.Invoke(hp - value);
            }

            hp = value;

            if (hp <= 0)
            {
                hp = 0;
                onCharacterDeathEvent.Invoke();
                EventManager.Instance.onCharacterDeath.Invoke(this);
            }
        }
    }

    public List<Module> Modules { get; private set; } = new();
    #endregion

    // These are local events that can be captured by child Modules. By
    // convention, please make sure to invoke these before related events in
    // EventManager.
    #region Local Events
    /// <summary>
    /// Called on character death.
    /// </summary>
    public readonly UnityEvent onCharacterDeathEvent = new();

    /// <summary>
    /// Called on character hurt.
    /// 
    /// <br/>
    /// 
    /// T0 = Damage taken.
    /// </summary>
    public readonly UnityEvent<int> onCharacterHurtEvent = new();
    #endregion

    #region Methods
    #region Instantiation
    private void Awake()
    {
        SetVars();
        HP = maxHP;
        damageInvulnerability = new(GameManager.Instance.damageTickRate);
    }

    // private void OnValidate()
    // {
    //     SetVars();
    // }

    private void SetVars()
    {
        // Create new modules.
        if (this.HasComponentInChildren(out SpriteRenderer sr))
        {
            // Automatically adds a HurtFlashModule to the first sprite renderer
            // found, if it doesn't already have one.
            sr.gameObject.AddComponentIfMissing<HurtFlashModule>();
        }

        // Get existing modules + other vars.
        GetComponentsInChildren(true, Modules);
        Modules.ForEach(module => module.LinkToMaster(this));

        this.RequireComponent(out r2d);
        this.RequireComponent(out c2d);

        this.RequireComponent(out flipModule);

        if (!gameObject.AddComponentIfMissing(out defaultAudioSource))
        {
            // Only set spacial blend if creating a new audio source.
            defaultAudioSource.spatialBlend = 1;
        }

        IsPlayer = this.HasComponentInChildren<PlayerControlModule>();
    }
    #endregion

    #region MonoBehavior Methods
    private void Update()
    {
        // Required to get this to work properly.
        damageInvulnerability.IncrementUpdate(false);
    }
    #endregion

    #region Flipping Methods
    /// <inheritdoc cref="DefaultFlipModule.SetFacingAngle(float)"/>
    public void SetLookAngle(float theta)
    {
        flipModule.SetFacingAngle(theta);
    }
    #endregion

    #region Health Methods
    /// <summary>
    /// Take <paramref name="damage"/> amount of damage.
    /// </summary>
    /// <param name="damage">How much damage to take.</param>
    /// <param name="force">The force direction. This vector is not normalized.
    /// Make sure to do so yourself if desired.</param>
    /// <returns>True if damage is successfully applied, false otherwise (such
    /// as when the character is invulnerable).</returns>
    public bool TakeDamage(int damage, Vector2 force)
    {
        if (damageInvulnerability.IsDone)
        {
            HP -= damage;

            if (damage > 0)
            {
                r2d.AddForce(force * knockbackMultiplier, ForceMode2D.Impulse);
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Restores health, ignoring damage invulnerability.
    /// </summary>
    /// <param name="restore">Amount of health to restore.</param>
    public void RestoreHealth(int restore)
    {
        HP += restore;
    }
    #endregion

    #region Audio Methods
    /// <summary>
    /// Plays the specified audio clip using the <see
    /// cref="defaultAudioSource"./>
    /// </summary>
    /// <param name="clip">The specified audio clip.</param>
    public void PlayClip(AudioClip clip)
    {
        defaultAudioSource.PlayOneShot(clip);
    }
    #endregion
    #endregion
}